# 3.1 Типы данных

Типы данных играют ключевую роль в определении правил хранения и представления информации. Есть несколько причин, почему их использование является необходимым:

- **Ограничение диапазона данных.** - Типы данных позволяют определить какое значение должно быть сохранено в определенных полях. Числовые поля могут принимать только числовые значения, это исключает возможность хранения текста в этих полях
  
- **Эффективное управление хранением данных.** - Использование различных типов данных позволяет более компактно хранить информацию. Числовые и дата/время значения могут быть сохранены в более оптимизированном формате по сравнению со строковым
  
- **Сортировка данных.** - Множество типов данных позволяют определить собственные правила сравнения для каждого типа. Например строковые значения сравниваются лексикографически, сравнение происходит посимвольно.

# Строковые типы данных

**Строковые типы данных** используются чаще всего, для хранения ФИО, моделей машин, названия городов и тд. Значения, принадлежащие этим типам называются **строками.**

Строки бывают двух видов **фиксированной** и **переменной** длины. Строки фиксированной длины состоят из фиксированного количества символов. Например мы можем разрешить ввод 30 символов в поле в котором хранятся имена и тд.

Строки переменной длины не имеют фиксированной длины и состоят ровно из того количества символов сколько указано в них самих.

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Не смотря на то, что строки переменной длины обладают большей гибкостью и хранят столько символов сколько необходимо СУБД, они обрабатываются СУБД намного медленее. СУБД манипулирует строками фиксированной длины намного быстрее.
</p>
</div>
</kbd>

Существуют два основных строковых типа данных - `CHAR` и `VARCHAR`

- `CHAR(n)`, где `n` - число в диапазное `[0;255]` представляющее допустимую длину строки. Хранит строку **фиксированной** длины, которая задается на этапе создания таблицы. Если строка имеет длину меньшую, чем `n`, то оставшиеся символы заполняются пробелами

- `VARCHAR(n)`, где `n` - число в диапазоне `[0;65535]`, представляющее допустимую длину строки. Хранит строку **переменной длины**, которая также задается на этапе создания таблицы. В отличие от `CHAR`, строка не заполняется пробелами, если длина меньше чем `n`. 


| Строка   | CHAR(4)  | VARCHAR(4)|
|----------|----------|-----------|
| `''`     | `    `   | `''`      |
| `bee`    | `bee `   | `bee`     |
| `geek`   | `geek`   | `geek`    |
| `beegeek`| `beeg`   | `beegeek` |

В отличие от типов данных `CHAR(n)` и `VARCHAR(n)` где, мы указываем максимальную длину строки (значение `n`), мы также можем использовать следующие типы данных:

|   Тип       | Размер(в байтах)| Максимальное количество символов |
|-------------|-----------------|----------------------------------|
| `TINYTEXT`  | `255`           | `255`                            |
| `TEXT`      | `65535`         | `2^16 - 1`                       |
| `MEDIUMTEXT`| `16777215`      | `2^24 - 1`                       |
| `LONGTEXT`  | `4294967295`    | `2^32 - 1`                       |

Для этих типов не указывается максимальная длина, она ограничивается только самим типом данных.

# Числовые типы данных

Чем шире поддерживаемый диапазон числового типа данных, тем больше нужно места для хранения числа.

# Целые числа

**Целые числа** хранят только числа без дробной части. Они делятся на числа со знаком (**signed**) и числа без знака (**unsigned**). Типы signed позволяют хранить положительны и отрицательные значения. Типы unsigned хранят только положительные числа, но поддерживают большой диапазон значений.

|   Тип       | Размер(в байтах)| Диапазон signed                  | Диапазон unsigned |
|-------------|-----------------|----------------------------------|-------------------|
| `TINYTINT`  | `1`             | `[-128; 127]`                    | `[0; 255]`        |
| `SMALLINT`  | `2`             | `[-2^15; 2^15 - 1]`              | `[0; 2^16 - 1]`   |
| `MEDIUMINT` | `3`             | `[-2^23; 2^23 - 1]`              | `[0; 2^24 - 1]`   | 
| `INT`       | `4`             | `[-2^31; 2^31 - 1]`              | `[0; 2^32 - 1]`   |
| `BIGINT`    | `8`             | `[-2^63; 2^63 - 1]`              | `[0; 2^64 - 1]`   |

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Числа без знака могут быть полезны в том случае, когда необходимо хранить значения которые не могут быть заведомо отрицательными(возраст человека, количество товара)
</p>
</div>
</kbd>


# Числа с плавающей точкой

**Числа с плавающей** точкой хранят приблизительные значения. Они не резервируют определенное количество бит для целочисленной или дробной частей, поэтому у всех значений в таблице количество цифр до и после запятой будет разным.

|   Тип       | Размер(в байтах)| Диапазон                         |
|-------------|-----------------|----------------------------------|
| `FLOAT`     | `4`             | `[1.17 * 10^-38; 3.4 * 10^38]`   |
| `DOUBDLE`   | `8`             | `[2.2 * 10^-308; 1.7 * 10^308]`  |

Значение в таблице представляет собой диапазон чисел в научной нотации.

Для `[1.17 * 10^-38; 3.4 * 10^38]` это:

- Первая часть `1.17 * 10^-38` означает, что самое маленькое число в этом диапазоне равно 1.17 умноженное на 10 в степени -38 (это очень маленькое число).
- Вторая часть `3.4 * 10^38` означает, что самое большое число в этом диапазоне равно 3.4 умноженное на 10 в степени 38 (это очень большое число).

То же самое и для `[2.2 * 10^-308; 1.7 * 10^308]`


# Числа с фиксированной точкой

**Числа с фиксированной точкой** используются для сохранения заданной точности. Такие числа резервируют определенное количество бит для целочисленной и дробной частей. Независимо от того, насколько большое или маленькое число, оно всегда будет использовать одно и то же количество бит для сохранения каждой части.

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Числа с фиксированной точкой особенно полезны в средах где важна точность, например при работе с денежными средствами или научными инженерными вычислениями.
</p>
</div>
</kbd>

В `MySQL` для хранения чисел с фиксированной точкой используются типы `DECIMAL(M, D)` и `NUMERIC(M, D)` . Эти типы являются синонимами, поэтому можно использовать любой из них. Диапазон значений задается параметрами `M` и `D`, где `M` - общее количество цифр, `D` - количество цифр, используемое для дробной части. Значение параметра `M` ограничено диапазоном `[1; 65]` .

Например `DECIMAL(5, 2)` означает, что в поле могут храниться числа, имеющие максимум `5` цифр, причем `2` из них отведены по десятичную часть. Другими словами, в этом поле могут храниться значения в диапазоне `[-999.99;999.99]`

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Если для типа DECIMAL не указать параметр D или сделать его равным нулю, значения будут округляться до целого числа по правилам математики. Например 99.5 сохранится со значением 100, а 99.4 - со значением 99
</p>
</div>
</kbd>

# Типы данных даты и времени

Все СУБД поддерживают типы данных для хранения значений даты и времени. Аналогично числовым типам, в большинстве СУБД имеется несколько типов данных даты и времени, каждый из которых имеет свой диапазон. 

К основным типам данных даты и времени относятся:

|     Тип     |         Формат       |              Диапазон значений             | Размер (в байтаъ) |
|-------------|----------------------|--------------------------------------------|-------------------|
| `DATE`      | `YYYY-MM-DD`         | `1000-01-01 – 9999-12-31`                  | `3`               |
| `TIME`      | `HH:MM:SS`           | `00:00:00 – 23:59:59`                      | `3`               |
| `DATETIME`  | `YYYY-MM-DD HH:MM:SS`| `1000-01-01 00:00:00 – 9999-12-31 23:59:59`| `8`               | 
| `TIMESTAMP` | `YYYY-MM-DD HH:MM:SS`| `1970-01-01 00:00:00 – 2038-01-19 08:14:07`| `4`               |
| `YEAR`      | `YYYY`               | `1901 – 2155`                              | `1`               |

# Типы данных DATETIME и TIMESTAMP

Типы `DATETIME` и `TIMESTAMP` на первый взгляд очень похожи. Они предназначены для хранения даты и времени и имеют одинаковый формат. Но у них есть ряд отличий, с помощью которых можно определить, какой из этих типов следует использовать.

`DATETIME` хранит значения от `1000-01-01 00:00:00` до `9999-12-31 23:59:59` включительно и не зависит от временной зоны. Он всегда отображается ровно в том виде, в котором был установлен и в котором хранится база данных. Другими словами, при изменении часового пояса, отображение времени не изменится.

`TIMESTAMP` хранит информацию о том, сколько прошло секунд с начала эпохи, то есть с `1970-01-01 00:00:00`. При создании записи в поле, использующем этот тип данных, значение сохраняется по **нулевому** часовому поясу, а при выборке из базы отображается с учетом **текущего** часового пояса, который задается в настройках операционной системы, где работает `MySQL`

# Тип данных NULL

Тип данных `NULL` - это специальное значение, которое используется в SQL для обозначения отсутствия данных. Оно отличается от пустой строки или нулевого значения, так как в действительности означает полное отсутствие данных, в то время как ноль является допустимым числовым значением, а пустая строка - допустимой строкой нулевой длины.

#### Примечание 1. 

Одним из поддерживаемых `MySQL` типов данных является `ENUM`(перечисление). Поле таблицы с таким типом данных может содержать только те значения, которые были указаны для этого поля при создании таблицы. Например если для поля, в котором хранится информация о половой принадлежности человека указать тип данных `ENUM` со значением `male` и `female`, то попытка установить какие-либо другие значения приведет к ошибке.

#### Примечание 2.

В разных СУБД могут использоваться разные псевдонимы для типов данных.

#### Примечание 3. 

Некоторые данные (например номера телефонов или почтовые индексы) содержат только числа, но это не значит, что они должны храниться в числовых полях. Например, если мы сохраним почтовый индекс 01234 в числовом поле, то сохранено будет число 1234, что приведет к потере первой цифры.

# 3.1 Извлечение данных

# Запросы и операторы

**SQL-запрос** представляет собой команду которую мы отправляем базе данных для решения определенных задач, таких как изменение, добавление, удаление. Каждый запрос состоит из **операторов** определяющих необходимые действия.

Операторы также называют **ключевыми словами**. Они представляют собой зарезервированные слова, которые имеют специальное значение и выполняют определенные функции в синтаксисе языка **SQL**. **Операторы не могут быть использованы в качестве имен таблиц, полей и других объектов базы данных.**

Запрос ниже извлекает из таблицы `Songs` все записи, которые в качестве значения поля `streams` имеют целочисленное значение которое превышает 100000:

```
SELECT *
FROM Songs
WHERE streams > 100000;
```

Запрос состоит из ключевых слов `SELECT`, `FROM`, `WHERE` и заканчивается символом `;` который символизирует конец операции. SQL-запросы могут быть сложными и состоять из нескольких операций, для разделения друг друга используется символ `;`. 

Запрос ниже создает таблицу с именем `Songs`, добавляет в нее две записи, наполняет данными а затем извлекает из нее информацию.

```
CREATE TABLE Songs                               -- операция создания таблицы
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    trackname VARCHAR(30),
    artist    VARCHAR(30)
);                                               -- завершение операции

INSERT INTO Songs (trackname, artist)            -- операция наполнения таблицы
VALUES ('Crazy On You', 'Heart'),
       ('My Lover', 'The Sounds');               -- завершение операции

SELECT *                                         -- операция извлечения данных из таблицы
FROM Songs;   
```

# Оператор SELECT

Чаще всего задачи которые обычно приходится выполнять с базой данных сводятся к извлечению необходимой информации. Получение конкретной записи, находящейся в одной из таблиц или несколько записей удовлетворяющих определенным условиям. За все подобные задачи связанные с получением данных отвечает оператор - `SELECT`.

Чтобы при помощи оператора `SELECT` извлечь данные из базы, нужно указать как минимум две вещи: что именно нужно извлечь и откуда. Простейший запрос который извлекает одно определенное поле из таблицы:

```
SELECT trackname
FROM Songs;
```

Результат:

```
+----------------------+
| trackname            |
+----------------------+
| Crazy on You         |
| My Lover             |
| Running up That Hill |
| Thrill               |
| Spent the Day in Bed |
+----------------------+
```

Здесь оператор `SELECT` извлекает поле `trackname` из таблицы `Songs`. Имя поля указывается сразу после ключевого слова `SELECT`, а ключевое слово `FROM` указывает на таблицу, из которой извлекаются данные. Этот запрос извлекает все записи таблицы не выполняя фильтрации.

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Операторы не чувствительны к регистру, записи SELECT, select и Select эквивалентны. Чаще всего используется верхний регистр
</p>
</div>
</kbd>

Для извлечения нескольких полей из таблицы, нужно через запятую перечислить их имена:

```
SELECT trackname, artist, streams
FROM Songs;
```

Результат:

```
+----------------------+------------+---------+
| trackname            | artist     | streams |
+----------------------+------------+---------+
| Crazy on You         | Heart      | 76338   |
| My Lover             | The Sounds | 99488   |
| Running up That Hill | Kate Bush  | 121495  |
| Thrill               | The Sounds | 49345   |
| Spent the Day in Bed | Morrissey  | 174994  |
+----------------------+------------+---------+
```

Поля возвращаются в том порядке в котором они были указаны в запросе:

```
SELECT streams, artist, trackname
FROM Songs;
```

Результат:

```
+---------+------------+----------------------+
| streams | artist     | trackname            |
+---------+------------+----------------------+
| 76338   | Heart      | Crazy on You         |
| 99488   | The Sounds | My Lover             |
| 121495  | Kate Bush  | Running up That Hill |
| 49345   | The Sounds | Thrill               |
| 174994  | Morrissey  | Spent the Day in Bed |
+---------+------------+----------------------+
```

C помощью оператора `SELECT` можно запросить все поля не указывая каждое из них. Для этого вместо имён используется специальный групповой символ `*` : 

```
SELECT *
FROM Songs;
```

Результат:

```
+----+----------+----------------------+------------+---------+
| id | place    | trackname            | artist     | streams |
+----+----------+----------------------+------------+---------+
| 1  | 4        | Crazy on You         | Heart      | 76338   |
| 2  | 3        | My Lover             | The Sounds | 99488   |
| 3  | 2        | Running up That Hill | Kate Bush  | 121495  |
| 4  | 5        | Thrill               | The Sounds | 49345   |
| 5  | 1        | Spent the Day in Bed | Morrissey  | 174994  |
+----+----------+----------------------+------------+---------+
```

Символ `*` не так часто используется на практике, так как показывает все поля что снижает производительность запроса. Но есть одно преимущество, для нахождения неизвестных полей. 

# Извлечение уникальных записей

При извлечении одного или нескольких полей таблицы могут встречаться повторяющиеся значения, тогда в результирующей таблице они также будут повторяться. 

Результатом запроса:

```
SELECT artist
FROM Songs;
```

Будет:

```
+------------+
| artist     |
+------------+
| Heart      |
| The Sounds |
| Kate Bush  |
| The Sounds |
| Morrissey  |
+------------+
```

Чтобы извлечь только уникальные записи необходимо воспользоваться ключевым словом `DISTINCT`, которое указывается перед именами всех полей .

Результатом запроса:

```
SELECT DISTINCT artist
FROM Songs;
```

Будет:

```
+------------+
| artist     |
+------------+
| Heart      |
| The Sounds |
| Kate Bush  |
| Morrissey  |
+------------+
```

Ключевое слово `DISTINCT` применяется ко всем полям, а не только к тому, перед которым оно стоит, поэтому при его использовании для двух и более полей одинаковыми будут считаться лишь те записи, которые имеют одинаковые значения по всем полям. 

Результатом запроса:

```
SELECT DISTINCT trackname, artist
FROM Songs;
```

Будет:

```
+----------------------+------------+
| trackname            | artist     |
+----------------------+------------+
| Crazy on You         | Heart      |
| My Lover             | The Sounds |
| Running up That Hill | Kate Bush  |
| Thrill               | The Sounds |
| Spent the Day in Bed | Morrissey  |
+----------------------+------------+
```

Здесь вторая и четвертая запись считаются разными, так как их значения не совпадают по всем полям, а только по одному.

# Ограничение результатов запроса

При извлечении данных из таблицы, может потребоваться получить определенное количество записей, например 1. Сделать это можно с помощью ключевого слова `LIMIT`.

Результатом запроса:

```
SELECT trackname
FROM Songs
LIMIT 3;
```

Будет:

```
+----------------------+
| trackname            |
+----------------------+
| Crazy on You         |
| My Lover             |
| Running up That Hill |
+----------------------+
```

Запрос извлекает поле `trackname` а выражение `LIMIT 3` говорит о том , что должно быть извлечено не более трех записей. Если же необходимо получить следующие три записи, можно задать точку извлечения с помощью ключевого слова `OFFSET`. 

Результатом запроса:

```
SELECT trackname
FROM Songs
LIMIT 3
OFFSET 2;
```

Будет:

```
+----------------------+
| trackname            |
+----------------------+
| Running up That Hill |
| Thrill               |
| Spent the Day in Bed |
+----------------------+
```

Выражение `LIMIT 3 OFFSET 2` говорит о том, что должно быть извлечено три записи, начиная с записи с индексом два. Таким образом, первое число - это количество строк для извлечения, а второе - начальная точка. 

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Записи при использовании ключевого слова OFFSET индексируются с нуля, поэтому, например выражение LIMIT 1 OFFSET 1 вернет вторую запись, а не первую
</p>
</div>
</kbd>

Ключевое слово `LIMIT` лишь ограничивает количество извлекаемых записей, а не определяет их количество.
Например, если в таблице содержится пять записей, а ограничивающим значением является число десять, то извлечены будут все пять записей и только они. 

Результатом запроса:

```
SELECT trackname
FROM Songs
LIMIT 10;
```

Будет:

```
+----------------------+
| trackname            |
+----------------------+
| Crazy on You         |
| My Lover             |
| Running up That Hill |
| Thrill               |
| Spent the Day in Bed |
+----------------------+
```

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Ключевое слово OFFSET используется только в паре с ключевым словом LIMIT
</p>
</div>
</kbd>

# Псевдонимы

При извлечении полей таблицы они сохраняют исходные наименования в результирующей таблице, при необходимости можно воспользоваться **псевдонимами**, чтобы дать альтернативные имена. Делается это с помощью ключевого слова `AS`, которое располагается между исходным именем поля и новым.

Результатом запроса:

```
SELECT trackname AS 'Song name',
       artist AS Artist
FROM Songs;
```

Будет:

```
+----------------------+------------+
| Song name            | Artist     |
+----------------------+------------+
| Crazy On You         | Heart      |
| My Lover             | The Sounds |
| Running up That Hill | Kate Bush  |
| Thrill               | The Sounds |
| Spent the Day in Bed | Morrissey  |
+----------------------+------------+
```

**Обратите внимание: если псевдоним состоит из нескольких слов, он должен быть представлен строкой, заключенной в апострофы.**

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Псевдонимы могут содержать до 255 знаков, включая пробелы, цифры и специальные символы.
</p>
</div>
</kbd>

#### Примечание 1.

Записи в результирующей таблице могут отображаться в произвольном порядке. И это нормальное поведение, например это может быть порядок, в котором запись заносилась в таблицу. Главное чтобы запрос возвращал одни и те же записи.

#### Примечание 2.

Все лишние пробельные символы в запросе пропускаются при его обработке, поэтому запрос может быть записан как в одной длинной строке , так и разбит на несколько строк. 

Приведенные ниже запросы функционально полностью эквивалентны:

- ```
  SELECT trackname
  FROM Songs;
  ```

- ```
  SELECT trackname FROM Songs;
  ```

- ```
  SELECT
  trackname
  FROM
  Songs;
  ```

#### Примечание 3.

Оператор `SELECT` может использоваться не только для извлечения данных из базы, но и для вывода конкретных значений.

Например:

```
SELECT 'beegeek';
```

Результат:

```
+---------+
| beegeek |
+---------+
| beegeek |
+---------+
```

или:

```
SELECT 100, 200, 300;
```

Результат:

```
+-----+-----+-----+
| 100 | 200 | 300 |
+-----+-----+-----+
| 100 | 200 | 300 |
+-----+-----+-----+
```

#### Примечание 4. 

Как и во многих других языках, SQL поддерживает однострочные и многострочные комментарии.

Однострочные комментарии обозначаются двумя дефисами `(--)`:

```
-- это комментарий

SELECT trackname    -- это комментарий
FROM Songs;
```

Многострочные комментарии обрамляются сочетанием символов `/*`:

```
/* это
многострочный
комментарий */

SELECT trackname
FROM Songs;
```