# 3.1 Типы данных

Типы данных играют ключевую роль в определении правил хранения и представления информации. Есть несколько причин, почему их использование является необходимым:

- **Ограничение диапазона данных.** - Типы данных позволяют определить какое значение должно быть сохранено в определенных полях. Числовые поля могут принимать только числовые значения, это исключает возможность хранения текста в этих полях
  
- **Эффективное управление хранением данных.** - Использование различных типов данных позволяет более компактно хранить информацию. Числовые и дата/время значения могут быть сохранены в более оптимизированном формате по сравнению со строковым
  
- **Сортировка данных.** - Множество типов данных позволяют определить собственные правила сравнения для каждого типа. Например строковые значения сравниваются лексикографически, сравнение происходит посимвольно.

# Строковые типы данных

**Строковые типы данных** используются чаще всего, для хранения ФИО, моделей машин, названия городов и тд. Значения, принадлежащие этим типам называются **строками.**

Строки бывают двух видов **фиксированной** и **переменной** длины. Строки фиксированной длины состоят из фиксированного количества символов. Например мы можем разрешить ввод 30 символов в поле в котором хранятся имена и тд.

Строки переменной длины не имеют фиксированной длины и состоят ровно из того количества символов сколько указано в них самих.

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Не смотря на то, что строки переменной длины обладают большей гибкостью и хранят столько символов сколько необходимо СУБД, они обрабатываются СУБД намного медленее. СУБД манипулирует строками фиксированной длины намного быстрее.
</p>
</div>
</kbd>

Существуют два основных строковых типа данных - `CHAR` и `VARCHAR`

- `CHAR(n)`, где `n` - число в диапазное `[0;255]` представляющее допустимую длину строки. Хранит строку **фиксированной** длины, которая задается на этапе создания таблицы. Если строка имеет длину меньшую, чем `n`, то оставшиеся символы заполняются пробелами

- `VARCHAR(n)`, где `n` - число в диапазоне `[0;65535]`, представляющее допустимую длину строки. Хранит строку **переменной длины**, которая также задается на этапе создания таблицы. В отличие от `CHAR`, строка не заполняется пробелами, если длина меньше чем `n`. 


| Строка   | CHAR(4)  | VARCHAR(4)|
|----------|----------|-----------|
| `''`     | `    `   | `''`      |
| `bee`    | `bee `   | `bee`     |
| `geek`   | `geek`   | `geek`    |
| `beegeek`| `beeg`   | `beegeek` |

В отличие от типов данных `CHAR(n)` и `VARCHAR(n)` где, мы указываем максимальную длину строки (значение `n`), мы также можем использовать следующие типы данных:

|   Тип       | Размер(в байтах)| Максимальное количество символов |
|-------------|-----------------|----------------------------------|
| `TINYTEXT`  | `255`           | `255`                            |
| `TEXT`      | `65535`         | `2^16 - 1`                       |
| `MEDIUMTEXT`| `16777215`      | `2^24 - 1`                       |
| `LONGTEXT`  | `4294967295`    | `2^32 - 1`                       |

Для этих типов не указывается максимальная длина, она ограничивается только самим типом данных.

# Числовые типы данных

Чем шире поддерживаемый диапазон числового типа данных, тем больше нужно места для хранения числа.

# Целые числа

**Целые числа** хранят только числа без дробной части. Они делятся на числа со знаком (**signed**) и числа без знака (**unsigned**). Типы signed позволяют хранить положительны и отрицательные значения. Типы unsigned хранят только положительные числа, но поддерживают большой диапазон значений.

|   Тип       | Размер(в байтах)| Диапазон signed                  | Диапазон unsigned |
|-------------|-----------------|----------------------------------|-------------------|
| `TINYTINT`  | `1`             | `[-128; 127]`                    | `[0; 255]`        |
| `SMALLINT`  | `2`             | `[-2^15; 2^15 - 1]`              | `[0; 2^16 - 1]`   |
| `MEDIUMINT` | `3`             | `[-2^23; 2^23 - 1]`              | `[0; 2^24 - 1]`   | 
| `INT`       | `4`             | `[-2^31; 2^31 - 1]`              | `[0; 2^32 - 1]`   |
| `BIGINT`    | `8`             | `[-2^63; 2^63 - 1]`              | `[0; 2^64 - 1]`   |

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Числа без знака могут быть полезны в том случае, когда необходимо хранить значения которые не могут быть заведомо отрицательными(возраст человека, количество товара)
</p>
</div>
</kbd>


# Числа с плавающей точкой

**Числа с плавающей** точкой хранят приблизительные значения. Они не резервируют определенное количество бит для целочисленной или дробной частей, поэтому у всех значений в таблице количество цифр до и после запятой будет: разным.

|   Тип       | Размер(в байтах)| Диапазон                         |
|-------------|-----------------|----------------------------------|
| `FLOAT`     | `4`             | `[1.17 * 10^-38; 3.4 * 10^38]`   |
| `DOUBDLE`   | `8`             | `[2.2 * 10^-308; 1.7 * 10^308]`  |

Значение в таблице представляет собой диапазон чисел в научной нотации.

Для `[1.17 * 10^-38; 3.4 * 10^38]` это:

- Первая часть `1.17 * 10^-38` означает, что самое маленькое число в этом диапазоне равно 1.17 умноженное на 10 в степени -38 (это очень маленькое число).
- Вторая часть `3.4 * 10^38` означает, что самое большое число в этом диапазоне равно 3.4 умноженное на 10 в степени 38 (это очень большое число).

То же самое и для `[2.2 * 10^-308; 1.7 * 10^308]`


# Числа с фиксированной точкой

**Числа с фиксированной точкой** используются для сохранения заданной точности. Такие числа резервируют определенное количество бит для целочисленной и дробной частей. Независимо от того, насколько большое или маленькое число, оно всегда будет: использовать одно и то же количество бит для сохранения каждой части.

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Числа с фиксированной точкой особенно полезны в средах где важна точность, например при работе с денежными средствами или научными инженерными вычислениями.
</p>
</div>
</kbd>

В `MySQL` для хранения чисел с фиксированной точкой используются типы `DECIMAL(M, D)` и `NUMERIC(M, D)` . Эти типы являются синонимами, поэтому можно использовать любой из них. Диапазон значений задается параметрами `M` и `D`, где `M` - общее количество цифр, `D` - количество цифр, используемое для дробной части. Значение параметра `M` ограничено диапазоном `[1; 65]` .

Например `DECIMAL(5, 2)` означает, что в поле могут храниться числа, имеющие максимум `5` цифр, причем `2` из них отведены по десятичную часть. Другими словами, в этом поле могут храниться значения в диапазоне `[-999.99;999.99]`

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Если для типа DECIMAL не указать параметр D или сделать его равным нулю, значения будут округляться до целого числа по правилам математики. Например 99.5 сохранится со значением 100, а 99.4 - со значением 99
</p>
</div>
</kbd>

# Типы данных даты и времени

Все СУБД поддерживают типы данных для хранения значений даты и времени. Аналогично числовым типам, в большинстве СУБД имеется несколько типов данных даты и времени, каждый из которых имеет свой диапазон. 

К основным типам данных даты и времени относятся:

|     Тип     |         Формат       |              Диапазон значений             | Размер (в байтаъ) |
|-------------|----------------------|--------------------------------------------|-------------------|
| `DATE`      | `YYYY-MM-DD`         | `1000-01-01 – 9999-12-31`                  | `3`               |
| `TIME`      | `HH:MM:SS`           | `00:00:00 – 23:59:59`                      | `3`               |
| `DATETIME`  | `YYYY-MM-DD HH:MM:SS`| `1000-01-01 00:00:00 – 9999-12-31 23:59:59`| `8`               | 
| `TIMESTAMP` | `YYYY-MM-DD HH:MM:SS`| `1970-01-01 00:00:00 – 2038-01-19 08:14:07`| `4`               |
| `YEAR`      | `YYYY`               | `1901 – 2155`                              | `1`               |

# Типы данных DATETIME и TIMESTAMP

Типы `DATETIME` и `TIMESTAMP` на первый взгляд очень похожи. Они предназначены для хранения даты и времени и имеют одинаковый формат. Но у них есть ряд отличий, с помощью которых можно определить, какой из этих типов следует использовать.

`DATETIME` хранит значения от `1000-01-01 00:00:00` до `9999-12-31 23:59:59` включительно и не зависит от временной зоны. Он всегда отображается ровно в том виде, в котором был установлен и в котором хранится база данных. Другими словами, при изменении часового пояса, отображение времени не изменится.

`TIMESTAMP` хранит информацию о том, сколько прошло секунд с начала эпохи, то есть с `1970-01-01 00:00:00`. При создании записи в поле, использующем этот тип данных, значение сохраняется по **нулевому** часовому поясу, а при выборке из базы отображается с учетом **текущего** часового пояса, который задается в настройках операционной системы, где работает `MySQL`

# Тип данных NULL

Тип данных `NULL` - это специальное значение, которое используется в SQL для обозначения отсутствия данных. Оно отличается от пустой строки или нулевого значения, так как в действительности означает полное отсутствие данных, в то время как ноль является допустимым числовым значением, а пустая строка - допустимой строкой нулевой длины.

#### Примечание 1. 

Одним из поддерживаемых `MySQL` типов данных является `ENUM`(перечисление). Поле таблицы с таким типом данных может содержать только те значения, которые были указаны для этого поля при создании таблицы. Например если для поля, в котором хранится информация о половой принадлежности человека указать тип данных `ENUM` со значением `male` и `female`, то попытка установить какие-либо другие значения приведет к ошибке.

#### Примечание 2.

В разных СУБД могут использоваться разные псевдонимы для типов данных.

#### Примечание 3. 

Некоторые данные (например номера телефонов или почтовые индексы) содержат только числа, но это не значит, что они должны храниться в числовых полях. Например, если мы сохраним почтовый индекс 01234 в числовом поле, то сохранено будет число 1234, что приведет к потере первой цифры.

# 3.2 Извлечение данных

# Запросы и операторы

**SQL-запрос** представляет собой команду которую мы отправляем базе данных для решения определенных задач, таких как изменение, добавление, удаление. Каждый запрос состоит из **операторов** определяющих необходимые действия.

Операторы также называют **ключевыми словами**. Они представляют собой зарезервированные слова, которые имеют специальное значение и выполняют определенные функции в синтаксисе языка **SQL**. **Операторы не могут быть использованы в качестве имен таблиц, полей и других объектов базы данных.**

Запрос ниже извлекает из таблицы `Songs` все записи, которые в качестве значения поля `streams` имеют целочисленное значение которое превышает 100000:

```
SELECT *
FROM Songs
WHERE streams > 100000;
```

Запрос состоит из ключевых слов `SELECT`, `FROM`, `WHERE` и заканчивается символом `;` который символизирует конец операции. SQL-запросы могут быть сложными и состоять из нескольких операций, для разделения друг друга используется символ `;`. 

Запрос ниже создает таблицу с именем `Songs`, добавляет в нее две записи, наполняет данными а затем извлекает из нее информацию.

```
CREATE TABLE Songs                               -- операция создания таблицы
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    trackname VARCHAR(30),
    artist    VARCHAR(30)
);                                               -- завершение операции

INSERT INTO Songs (trackname, artist)            -- операция наполнения таблицы
VALUES ('Crazy On You', 'Heart'),
       ('My Lover', 'The Sounds');               -- завершение операции

SELECT *                                         -- операция извлечения данных из таблицы
FROM Songs;   
```

# Оператор SELECT

Чаще всего задачи которые обычно приходится выполнять с базой данных сводятся к извлечению необходимой информации. Получение конкретной записи, находящейся в одной из таблиц или несколько записей удовлетворяющих определенным условиям. За все подобные задачи связанные с получением данных отвечает оператор - `SELECT`.

Чтобы при помощи оператора `SELECT` извлечь данные из базы, нужно указать как минимум две вещи: что именно нужно извлечь и откуда. Простейший запрос который извлекает одно определенное поле из таблицы:

```
SELECT trackname
FROM Songs;
```

Результат:

```
+----------------------+
| trackname            |
+----------------------+
| Crazy on You         |
| My Lover             |
| Running up That Hill |
| Thrill               |
| Spent the Day in Bed |
+----------------------+
```

Здесь оператор `SELECT` извлекает поле `trackname` из таблицы `Songs`. Имя поля указывается сразу после ключевого слова `SELECT`, а ключевое слово `FROM` указывает на таблицу, из которой извлекаются данные. Этот запрос извлекает все записи таблицы не выполняя фильтрации.

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Операторы не чувствительны к регистру, записи SELECT, select и Select эквивалентны. Чаще всего используется верхний регистр
</p>
</div>
</kbd>

Для извлечения нескольких полей из таблицы, нужно через запятую перечислить их имена:

```
SELECT trackname, artist, streams
FROM Songs;
```

Результат:

```
+----------------------+------------+---------+
| trackname            | artist     | streams |
+----------------------+------------+---------+
| Crazy on You         | Heart      | 76338   |
| My Lover             | The Sounds | 99488   |
| Running up That Hill | Kate Bush  | 121495  |
| Thrill               | The Sounds | 49345   |
| Spent the Day in Bed | Morrissey  | 174994  |
+----------------------+------------+---------+
```

Поля возвращаются в том порядке в котором они были указаны в запросе:

```
SELECT streams, artist, trackname
FROM Songs;
```

Результат:

```
+---------+------------+----------------------+
| streams | artist     | trackname            |
+---------+------------+----------------------+
| 76338   | Heart      | Crazy on You         |
| 99488   | The Sounds | My Lover             |
| 121495  | Kate Bush  | Running up That Hill |
| 49345   | The Sounds | Thrill               |
| 174994  | Morrissey  | Spent the Day in Bed |
+---------+------------+----------------------+
```

C помощью оператора `SELECT` можно запросить все поля не указывая каждое из них. Для этого вместо имён используется специальный групповой символ `*` : 

```
SELECT *
FROM Songs;
```

Результат:

```
+----+----------+----------------------+------------+---------+
| id | place    | trackname            | artist     | streams |
+----+----------+----------------------+------------+---------+
| 1  | 4        | Crazy on You         | Heart      | 76338   |
| 2  | 3        | My Lover             | The Sounds | 99488   |
| 3  | 2        | Running up That Hill | Kate Bush  | 121495  |
| 4  | 5        | Thrill               | The Sounds | 49345   |
| 5  | 1        | Spent the Day in Bed | Morrissey  | 174994  |
+----+----------+----------------------+------------+---------+
```

Символ `*` не так часто используется на практике, так как показывает все поля что снижает производительность запроса. Но есть одно преимущество, для нахождения неизвестных полей. 

# Извлечение уникальных записей

При извлечении одного или нескольких полей таблицы могут встречаться повторяющиеся значения, тогда в результирующей таблице они также будут повторяться. 

Результатом запроса:

```
SELECT artist
FROM Songs;
```

будет:

```
+------------+
| artist     |
+------------+
| Heart      |
| The Sounds |
| Kate Bush  |
| The Sounds |
| Morrissey  |
+------------+
```

Чтобы извлечь только уникальные записи необходимо воспользоваться ключевым словом `DISTINCT`, которое указывается перед именами всех полей .

Результатом запроса:

```
SELECT DISTINCT artist
FROM Songs;
```

будет:

```
+------------+
| artist     |
+------------+
| Heart      |
| The Sounds |
| Kate Bush  |
| Morrissey  |
+------------+
```

Ключевое слово `DISTINCT` применяется ко всем полям, а не только к тому, перед которым оно стоит, поэтому при его использовании для двух и более полей одинаковыми будут считаться лишь те записи, которые имеют одинаковые значения по всем полям. 

Результатом запроса:

```
SELECT DISTINCT trackname, artist
FROM Songs;
```

будет:

```
+----------------------+------------+
| trackname            | artist     |
+----------------------+------------+
| Crazy on You         | Heart      |
| My Lover             | The Sounds |
| Running up That Hill | Kate Bush  |
| Thrill               | The Sounds |
| Spent the Day in Bed | Morrissey  |
+----------------------+------------+
```

Здесь вторая и четвертая запись считаются разными, так как их значения не совпадают по всем полям, а только по одному.

# Ограничение результатов запроса

При извлечении данных из таблицы, может потребоваться получить определенное количество записей, например 1. Сделать это можно с помощью ключевого слова `LIMIT`.

Результатом запроса:

```
SELECT trackname
FROM Songs
LIMIT 3;
```

будет:

```
+----------------------+
| trackname            |
+----------------------+
| Crazy on You         |
| My Lover             |
| Running up That Hill |
+----------------------+
```

Запрос извлекает поле `trackname` а выражение `LIMIT 3` говорит о том , что должно быть извлечено не более трех записей. Если же необходимо получить следующие три записи, можно задать точку извлечения с помощью ключевого слова `OFFSET`. 

Результатом запроса:

```
SELECT trackname
FROM Songs
LIMIT 3
OFFSET 2;
```

будет:

```
+----------------------+
| trackname            |
+----------------------+
| Running up That Hill |
| Thrill               |
| Spent the Day in Bed |
+----------------------+
```

Выражение `LIMIT 3 OFFSET 2` говорит о том, что должно быть извлечено три записи, начиная с записи с индексом два. Таким образом, первое число - это количество строк для извлечения, а второе - начальная точка. 

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Записи при использовании ключевого слова OFFSET индексируются с нуля, поэтому, например выражение LIMIT 1 OFFSET 1 вернет вторую запись, а не первую
</p>
</div>
</kbd>

Ключевое слово `LIMIT` лишь ограничивает количество извлекаемых записей, а не определяет их количество.
Например, если в таблице содержится пять записей, а ограничивающим значением является число десять, то извлечены будут все пять записей и только они. 

Результатом запроса:

```
SELECT trackname
FROM Songs
LIMIT 10;
```

будет:

```
+----------------------+
| trackname            |
+----------------------+
| Crazy on You         |
| My Lover             |
| Running up That Hill |
| Thrill               |
| Spent the Day in Bed |
+----------------------+
```

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Ключевое слово OFFSET используется только в паре с ключевым словом LIMIT
</p>
</div>
</kbd>

# Псевдонимы

При извлечении полей таблицы они сохраняют исходные наименования в результирующей таблице, при необходимости можно воспользоваться **псевдонимами**, чтобы дать альтернативные имена. Делается это с помощью ключевого слова `AS`, которое располагается между исходным именем поля и новым.

Результатом запроса:

```
SELECT trackname AS 'Song name',
       artist AS Artist
FROM Songs;
```

будет:

```
+----------------------+------------+
| Song name            | Artist     |
+----------------------+------------+
| Crazy On You         | Heart      |
| My Lover             | The Sounds |
| Running up That Hill | Kate Bush  |
| Thrill               | The Sounds |
| Spent the Day in Bed | Morrissey  |
+----------------------+------------+
```

**Обратите внимание: если псевдоним состоит из нескольких слов, он должен быть представлен строкой, заключенной в апострофы.**

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Псевдонимы могут содержать до 255 знаков, включая пробелы, цифры и специальные символы.
</p>
</div>
</kbd>

#### Примечание 1.

Записи в результирующей таблице могут отображаться в произвольном порядке. И это нормальное поведение, например это может быть порядок, в котором запись заносилась в таблицу. Главное чтобы запрос возвращал одни и те же записи.

#### Примечание 2.

Все лишние пробельные символы в запросе пропускаются при его обработке, поэтому запрос может быть записан как в одной длинной строке , так и разбит на несколько строк. 

Приведенные ниже запросы функционально полностью эквивалентны:

- ```
  SELECT trackname
  FROM Songs;
  ```

- ```
  SELECT trackname FROM Songs;
  ```

- ```
  SELECT
  trackname
  FROM
  Songs;
  ```

#### Примечание 3.

Оператор `SELECT` может использоваться не только для извлечения данных из базы, но и для вывода конкретных значений.

Например:

```
SELECT 'beegeek';
```

Результат:

```
+---------+
| beegeek |
+---------+
| beegeek |
+---------+
```

или:

```
SELECT 100, 200, 300;
```

Результат:

```
+-----+-----+-----+
| 100 | 200 | 300 |
+-----+-----+-----+
| 100 | 200 | 300 |
+-----+-----+-----+
```

#### Примечание 4. 

Как и во многих других языках, SQL поддерживает однострочные и многострочные комментарии.

Однострочные комментарии обозначаются двумя дефисами `(--)`:

```
-- это комментарий

SELECT trackname    -- это комментарий
FROM Songs;
```

Многострочные комментарии обрамляются сочетанием символов `/*`:

```
/* это
многострочный
комментарий */

SELECT trackname
FROM Songs;
```

# 3.3 Сортировка данных

Используемая база данных:

```
+----+-------+----------------------+------------+---------+--------------+
| id | place | trackname            | artist     | streams | release_date |
+----+-------+----------------------+------------+---------+--------------+
| 1  | 4     | Crazy On You         | Heart      | 76338   | 2009-12-19   |
| 2  | 3     | My Lover             | The Sounds | 99488   | 2009-05-31   |
| 3  | 2     | Running up That Hill | Kate Bush  | 121495  | 1985-08-05   |
| 4  | 5     | Thrill               | The Sounds | 49345   | 2016-11-11   |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 174994  | 2017-10-17   |
+----+-------+----------------------+------------+---------+--------------+
```

# Оператор ORDER BY

Часто при извлечении данных в результирующую таблицу, необходимо получить отсортированные данные. В этом нам поможет оператор `ORDER BY`. Чтобы извлечь информацию из базы данных в отсортированном виде, достаточно указать `ORDER BY` и имя сортируемого поля. 

Результатом запроса:

```
SELECT artist, trackname, release_date
FROM Songs
ORDER BY release_date;
```

будет:

```
+------------+----------------------+--------------+
| artist     | trackname            | release_date |
+------------+----------------------+--------------+
| Kate Bush  | Running up That Hill | 1985-08-05   |
| The Sounds | My Lover             | 2009-05-31   |
| Heart      | Crazy On You         | 2009-12-19   |
| The Sounds | Thrill               | 2016-11-11   |
| Morrissey  | Spent the Day in Bed | 2017-10-17   |
+------------+----------------------+--------------+
```

В этом примере извлекается информация о песнях, однако данные расположены не в произвольном порядке, по умолчанию `ORDER BY` сортирует по возрастанию, как мы это можем увидеть глядя в `release_date`. 

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
В запросе оператор ORDER BY должен следовать после операторов SELECT и FROM, иначе запрос завершится с ошибкой
</p>
</div>
</kbd>

# Сортировка по нескольким полям

Чаще всего сортировки по одному полю бывает недостаточно, так как несколько записей могут содержать одно и то же значение в том поле, по которому выполняется сортировка. Чтобы выполнить сортировку по нескольким полям, нужно перечислить их через запятую.

Результатом запроса:

```
SELECT artist, trackname, streams
FROM Songs
ORDER BY artist, streams;
```

будет:

```
+------------+----------------------+---------+
| artist     | trackname            | streams |
+------------+----------------------+---------+
| Heart      | Crazy On You         | 76338   |
| Kate Bush  | Running up That Hill | 121495  |
| Morrissey  | Spent the Day in Bed | 174994  |
| The Sounds | Thrill               | 49345   |
| The Sounds | My Lover             | 99488   |
+------------+----------------------+---------+
```

Запрос сначала выполняет сортировку по полю `artist`, затем по полю `streams`. Если какие либо две записи имеют разные значения в поле `artist`, они сортируются согласно этим значениям. Если какие-либо две записи имеют одинаковые значения в поле `artist`, они сортируются согласно значениям в поле `streams`.

# Сортировка по положению поля

Вместо имен полей, оператор `ORDER BY` позволяет указывать порядковый номер полей, по которым необходимо выполнить сортировку. Однако сортировка таким методом возможно только по тем полям, которые присутствуют в результирующей таблице. Нумеруются поля с единицы, первое поле результирующей таблицы имеет порядковый номер `1` второе `2` и тд.

Например запрос:

```
SELECT artist, trackname, streams
FROM Songs
ORDER BY artist, streams;
```

можно записать следующим образом:

```
SELECT artist, trackname, streams
FROM Songs
ORDER BY 1, 3;
```

И получится аналогичный результат:

```
+------------+----------------------+---------+
| artist     | trackname            | streams |
+------------+----------------------+---------+
| Heart      | Crazy On You         | 76338   |
| Kate Bush  | Running up That Hill | 121495  |
| Morrissey  | Spent the Day in Bed | 174994  |
| The Sounds | Thrill               | 49345   |
| The Sounds | My Lover             | 99488   |
+------------+----------------------+---------+
```

Второй запрос отличается от первого лишь тем что используются порядковые номера полей в результирующей таблице а не их имена. Поле `artist` = `1`, поле `streams` = `3`.

# Указание направления сортировки

Сортировать данные можно как по возрастанию так и по убыванию. Для сортировки в порядке убывания используется оператор `DESC`.

Результатом запроса:

```
SELECT place, trackname
FROM Songs
ORDER BY place DESC;
```

будет:

```
+-------+----------------------+
| place | trackname            |
+-------+----------------------+
| 5     | Thrill               |
| 4     | Crazy On You         |
| 3     | My Lover             |
| 2     | Running up That Hill |
| 1     | Spent the Day in Bed |
+-------+----------------------+
```

В этом примере данные сортируются по убыванию значения поля `place`. 

Важной особенностью ключевого слова `DESC` является то, что оно применяется только к тому полю, после которого стоит. Это необходимо учитывать при сортировке по нескольким полям.

Результатом запроса:

```
SELECT id, artist, trackname
FROM Songs
ORDER BY artist, id DESC;
```

будет:

```
+----+------------+----------------------+
| id | artist     | trackname            |
+----+------------+----------------------+
| 1  | Heart      | Crazy On You         |
| 3  | Kate Bush  | Running up That Hill |
| 5  | Morrissey  | Spent the Day in Bed |
| 4  | The Sounds | Thrill               |
| 2  | The Sounds | My Lover             |
+----+------------+----------------------+
```

Здесь сортировка выполняется по полям `artist` и `id`. Ключевое слово `DESC` указано лишь после поля `id`, поэтому сортировка происходит в порядке **возрастания** значения поля `artist`, а в случае совпадения - в порядке **убывания** значения поля `id`. 

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Если необходимо отсортировать записи в порядке убывания значений нескольких полей, нужно обязательно указывать оператор `DESC` после каждого из них.
</p>
</div>
</kbd>

#### Примечание 1.

Аналогично сортировке в порядке **убывания** оператором `DESC` существует оператор для сортировки в порядке **возрастания** `ASC`, использовать которое не обязательно.

Приведеннный ниже запрос:

```
SELECT title
FROM Songs
ORDER BY title;
```

Полностью идентичен следующему:

```
SELECT title
FROM Songs
ORDER BY title ASC;
```

#### Примечание 2.

Операторы `ORDER BY` и `LIMIT` могут использоваться вместе для решения различных задач. Например с их помощью можно определить две песни, вышедших позже остальных. Для этого сперва необходимо отсортировать музыкальные композиции в порядке убывания даты их выхода, а затем ограничить полученный результат до двух значений.

Результатом приведенного запроса:

```
SELECT artist, trackname, release_date
FROM Songs
ORDER BY release_date DESC
LIMIT 2;
```

будет:

```
+------------+----------------------+--------------+
| artist     | trackname            | release_date |
+------------+----------------------+--------------+
| Morrissey  | Spent the Day in Bed | 2017-10-17   |
| The Sounds | Thrill               | 2016-11-11   |
+------------+----------------------+--------------+
```

Подобные манипуляции с данными возможны благодаря порядку, в котором запрос выполняет свои операции. Сначала происходит выборка из `SONGS` затем сортировка с помощью `ORDER BY` и `DESC`, только после этого применяется ограничение вывода с помощью `LIMIT`.

#### Примечание 3.

Сортировка является одной из завершающих операций и выполняется уже после формирования результирующей таблицы, поэтому в блоке оператора `ORDER BY` можно указывать как фактические имена полей таблицы, из которой извлекаются данные так и псевдонимы.

Результатом запроса:

```
SELECT artist, trackname AS track, release_date
FROM Songs
ORDER BY track;
```

будет:

```
+------------+----------------------+--------------+
| artist     | track                | release_date |
+------------+----------------------+--------------+
| Heart      | Crazy On You         | 2009-12-19   |
| The Sounds | My Lover             | 2009-05-31   |
| Kate Bush  | Running up That Hill | 1985-08-05   |
| Morrissey  | Spent the Day in Bed | 2017-10-17   |
| The Sounds | Thrill               | 2016-11-11   |
+------------+----------------------+--------------+
```

Если псевдоним состоит из нескольких слов, то при сортировке его обязательно нужно заключать в обратные апострофы(` `` `) 

Результатом запроса:

```
SELECT artist, trackname AS 'track name'
FROM Songs
ORDER BY `track name`;
```

будет:

```
+------------+----------------------+
| artist     | track name           |
+------------+----------------------+
| Heart      | Crazy On You         |
| The Sounds | My Lover             |
| Kate Bush  | Running up That Hill |
| Morrissey  | Spent the Day in Bed |
| The Sounds | Thrill               |
+------------+----------------------+
```

#### Примечание 4.

Ключевое слово `DESC` - это сокращение от `DESCENDING` (убывание). Его антоним `ASC` - сокращение от `ASCENDING` (возрастание).


#### Примечание 5.

При сортировке строковых значений, регистр не учитывается. Данное поведение можно изменить в настройках СУБД, однако выбирать учитывать регистр или нет, с помощью оператора `ORDER BY` нельзя.

# 3.4 Фильтрация данных. Часть 1

Используемая база данных:

```
+----+-------+----------------------+------------+---------+--------------+
| id | place | trackname            | artist     | streams | release_date |
+----+-------+----------------------+------------+---------+--------------+
| 1  | 4     | Crazy On You         | Heart      | 76338   | NULL         |
| 2  | 3     | My Lover             | The Sounds | 99488   | NULL         |
| 3  | 2     | Running up That Hill | Kate Bush  | 121495  | 1985-08-05   |
| 4  | 5     | Thrill               | The Sounds | 49345   | 2016-11-10   |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 174994  | 2017-09-19   |
+----+-------+----------------------+------------+---------+--------------+
```

# Оператор WHERE

Для извлечения некоторой части информации из баз данных используется оператор `WHERE`, который позволяет указывать определенные условия при извлечении записей. Если запись удовлетворяет этим условиям, она попадает в результирующую таблицу, в противном случае отбрасывается. 

В качестве примера, запрос который извлекает данные о песнях конкретного исполнителя:

```
SELECT *
FROM Songs
WHERE artist = 'The Sounds';
```

Результатом будет:

```
+----+----------+-----------+------------+---------+--------------+
| id | place    | trackname | artist     | streams | release_date |
+----+----------+-----------+------------+---------+--------------+
| 2  | 3        | My Lover  | The Sounds | 99488   | NULL         |
| 4  | 5        | Thrill    | The Sounds | 49345   | 2016-11-10   |
+----+----------+-----------+------------+---------+--------------+
```

В данном примере используется простая проверка на равенство. Запрос извлекает все поля таблицы, но возвращает не все записи, а только те поля `artist`, которые равны `The Sounds`.

Оператор `WHERE` указывается после названия таблицы. Оператор `WHERE` может совместно использоваться с оператором `ORDER BY`, в таком случае оператор `ORDER BY`, должен распологаться после оператора `WHERE`.

Результатом запроса:

```
SELECT *
FROM Songs
WHERE artist = 'The Sounds'
ORDER BY streams;
```

будет:

```
+----+----------+-----------+------------+---------+--------------+
| id | place    | trackname | artist     | streams | release_date |
+----+----------+-----------+------------+---------+--------------+
| 4  | 5        | Thrill    | The Sounds | 49345   | 2016-11-10   |
| 2  | 3        | My Lover  | The Sounds | 99488   | NULL         |
+----+----------+-----------+------------+---------+--------------+
```

# Операторы сравнения

Условия после оператора `WHERE` может являться не только проверкой на равенство. В SQL поддерживается целый набор операторов сравнения, которые перечислены в таблице:

|       Оператор      |        Проверка        |
|---------------------|------------------------|
| `=`                 | Равенство              |
| `<=>`               | Эквивалентность        |
| `!=` или `<>`       | Неравенство            |
| `<`                 | Меньше                 |
| `<=`                | Меньше или равно       |
| `>`                 | Больше                 |
| `>=`                | Больше или равно       |
| `BETWEEN`           | Вхождение в диапазон   |
| `IS NULL`           | Значение `NULL`        |
| `IS NOT NULL`       | Не значение `NULL`     |

Теперь попробуем воспользоваться другими операторами сравнения.

# Сравнение с одиночным значением

**Пример 1.** Извлечем из таблицы `Songs` данные о песнях, количество прослушиваний которых превышает `100000`.

Результатом запроса:

```
SELECT trackname, artist, streams
FROM Songs
WHERE streams > 100000;
```

будет:

```
+----------------------+-----------+---------+
| trackname            | artist    | streams |
+----------------------+-----------+---------+
| Running up That Hill | Kate Bush | 121495  |
| Spent the Day in Bed | Morrissey | 174994  |
+----------------------+-----------+---------+
```

**Пример 2.** Извлечем из таблицы `Songs` данные о песнях, которые входят в тройку лучших композиций, и отсортируем их по занимаемой позиции.

Результатом запроса:

```
SELECT place, trackname, artist
FROM Songs
WHERE place <= 3
ORDER BY place;
```

будет:

```
+----------+----------------------+------------+
| place    | trackname            | artist     |
+----------+----------------------+------------+
| 1        | Spent the Day in Bed | Morrissey  |
| 2        | Running up That Hill | Kate Bush  |
| 3        | My Lover             | The Sounds |
+----------+----------------------+------------+
```

**Пример 3.** Извлечем из таблицы `Songs` данные о песнях, которые не принадлежат группе `The Sounds`.

Результатом запроса:

```
SELECT trackname, artist
FROM Songs
WHERE artist != 'The Sounds';
```

будет:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Операторы != и <> обычно взаимозаменяемы, однако не во всех СУБД поддерживаются обе формы оператора.
</p>
</div>
</kbd>

# Сравнение с диапазоном значений

Для сравнения с диапазоном значений используется оператор `BETWEEN`. Его синтаксис немного отличается от других операторов, так как для него требуется два значения, начальное и конечное.

**Пример 1.** Извлечем из таблицы Songs данные о песнях, количество прослушиваний которых находится в диапазоне `[50000; 100000]`.

Результатом запроса:

```
SELECT trackname, artist, streams
FROM Songs
WHERE streams BETWEEN 50000 AND 100000;
```

будет:

```
+--------------+------------+---------+
| trackname    | artist     | streams |
+--------------+------------+---------+
| Crazy on You | Heart      | 76338   |
| My Lover     | The Sounds | 99488   |
+--------------+------------+---------+
```

При использовании оператора `BETWEEN` нужно указывать два значения: нижнюю и верхнюю границы диапазона. Оба значения должны быть разделены ключевым словом `AND`. При этом извлекаются все значения из диапазона, включая те, что равны граничным значениям.

**Пример 2.** Извлечем из таблицы `Songs` данные о песнях, которые занимают второе, третье и четвертое места, и отсортируем их по занимаемой позиции.

Результатом запроса:

```
SELECT place, trackname, artist
FROM Songs
WHERE place BETWEEN 2 AND 4
ORDER BY place;
```

будет:

```
+----------+----------------------+------------+
| place    | trackname            | artist     |
+----------+----------------------+------------+
| 2        | Running up That Hill | Kate Bush  |
| 3        | My Lover             | The Sounds |
| 4        | Crazy on You         | Heart      |
+----------+----------------------+------------+
```

# Проверка на присутствие и отсутствие значения 

Чтобы проверить содержит ли поле `NULL`, нельзя просто записать `<название_поля> = NULL`, поскольку значение `NULL` трактуется как неопределенное, и мы не можем выполнить проверку такого значения ни на равенство, ни на не равенство.

Для определения того, находится ли в поле значение `NULL`, предусмотрен оператор `IS NULL`. Противоположным для него оператором является `IS NOT NULL`, который позволяет определить, что в поле **не находится** значение `NULL`.

**Пример 1.** Извлечем из таблицы `Songs` данные о песнях, которые не имеют даты выхода.

Результатом запроса:

```
SELECT trackname, artist, release_date
FROM Songs
WHERE release_date IS NULL;
```

будет:

```
+--------------+------------+--------------+
| trackname    | artist     | release_date |
+--------------+------------+--------------+
| Crazy on You | Heart      | NULL         |
| My Lover     | The Sounds | NULL         |
+--------------+------------+--------------+
```

**Пример 2.** Извлечем из таблицы `Songs` данные о песнях, которые имеют дату выхода, и отсортируем их по этой дате в порядке убывания.

Результатом запроса:

```
SELECT trackname, artist, release_date
FROM Songs
WHERE release_date IS NOT NULL
ORDER BY release_date DESC;
```

будет:

```
+----------------------+------------+--------------+
| trackname            | artist     | release_date |
+----------------------+------------+--------------+
| Spent the Day in Bed | Morrissey  | 2017-09-19   |
| Thrill               | The Sounds | 2016-11-10   |
| Running up That Hill | Kate Bush  | 1985-08-05   |
+----------------------+------------+--------------+
```

#### Примечание 1.

Псевдонимы не могут быть использованы в блоке оператора `WHERE` для фильтрации записей.

Результатом запроса:

```
​SELECT trackname, artist, streams AS auditions
FROM Songs
WHERE auditions > 100000;
```

будет ошибка:

```
ERROR 1054: Unknown column 'auditions' in 'where clause'
```

Это связано с тем что блок `WHERE` обрабатывается до блока `SELECT`, поэтому на момент выполнения блока `WHERE` псевдонимы полей еще неизвестны.

#### Примечание 2.

В зависимости от оператора и сравниваемых значений результатом операции сравнения могут являться следующие значения:

- `1` - эквивалентно истине;
- `0` - эквивалентно лжи;
- `NULL` - эквивалентно неопределенности;

Результатом запроса:

```
SELECT 'x' = 'x',
       'x' <=> 'x',
       'x' <=> 'y',
       'x' != 'z',
       5 < 10,
       10 <= 10,
       5 > 10,
       10 >= 5;
```

будет:

```
+-----------+-------------+-------------+------------+--------+----------+--------+---------+
| 'x' = 'x' | 'x' <=> 'x' | 'x' <=> 'y' | 'x' != 'z' | 5 < 10 | 10 <= 10 | 5 > 10 | 10 >= 5 |
+-----------+-------------+-------------+------------+--------+----------+--------+---------+
| 1         | 1           | 0           | 1          | 1      | 1        | 0      | 1       |
+-----------+-------------+-------------+------------+--------+----------+--------+---------+
```

Результат сравнения любого значения с `NULL` является `NULL`.

Результатом запроса:

```
SELECT 'x' != NULL,
       10 > NULL,
       NULL = NULL;
```

будет:

```
+-------------+-----------+-------------+
| 'x' != NULL | 10 > NULL | NULL = NULL |
+-------------+-----------+-------------+
| NULL        | NULL      | NULL        |
+-------------+-----------+-------------+
```

Исключением является оператор эквивалентности, который аналогичен оператору равенства лишь с той разницей, что результат будет равен `1` в случае сравнения `NULL` с `NULL` и `0`, когда идет сравнение любого отличного от `NULL` значения с `NULL`.

Результатом запроса:

```
SELECT 'x' <=> NULL,
       '5' <=> NULL,
       NULL <=> NULL;
```

будет:

```
+--------------+--------------+---------------+
| 'x' <=> NULL | '5' <=> NULL | NULL <=> NULL |
+--------------+--------------+---------------+
| 0            | 0            | 1             |
+--------------+--------------+---------------+
```

#### Примечание 3. 

По умолчанию операторы сравнения не учитывают регистр при сравнении строковых значений. 

Результатом запроса:

```
SELECT 'bee' = 'Bee',
       'bee' <=> 'Bee',
       'bee' > 'Bee',
       'bee' < 'Bee';
```

будет:

```
+---------------+-----------------+---------------+---------------+
| 'bee' = 'Bee' | 'bee' <=> 'Bee' | 'bee' > 'Bee' | 'bee' < 'Bee' |
+---------------+-----------------+---------------+---------------+
| 1             | 1               | 0             | 0             |
+---------------+-----------------+---------------+---------------+
```

#### Примечание 4.

Оператор `LIMIT` при его использовании совместно с оператором `WHERE` или сочетанием `WHERE` и `ORDER BY` должен распологаться после них.

Результатом запроса:

```
SELECT place, trackname, artist
FROM Songs
WHERE place <= 4
LIMIT 2;
```

будет:

```
+-------+--------------+------------+
| place | trackname    | artist     |
+-------+--------------+------------+
| 4     | Crazy on You | Heart      |
| 3     | My Lover     | The Sounds |
+-------+--------------+------------+
```

Это связано с порядком, в котором запрос выполняет свои операции:

- сначала извлекает из таблицы записи, удовлетворяющие заданным условиям;
- затем сортирует;
- только после этого ограничивает определенным количеством;

# 3.5 Фильтрация данных. Часть 2

Используемая база данных:

```
+----+----------+----------------------+------------+---------+--------------+
| id | place    | trackname            | artist     | streams | release_date |
+----+----------+----------------------+------------+---------+--------------+
| 1  | 4        | Crazy On You         | Heart      | 76338   | 1976-03-01   |
| 2  | 3        | My Lover             | The Sounds | 99488   | 2009-05-31   |
| 3  | 2        | Running up That Hill | Kate Bush  | 121495  | 1985-08-05   |
| 4  | 5        | Thrill               | The Sounds | 49345   | 2016-11-10   |
| 5  | 1        | Spent the Day in Bed | Morrissey  | 174994  | 2017-09-19   |
+----+----------+----------------------+------------+---------+--------------+
```

# Операторы AND и OR

В SQL как и во многих других языках программирования, можно использовать несколько условий чтобы создавать сложные фильтры. Для этого предназначены логические операторы `AND` и `OR`.

# Оператор AND

Чтобы отфильтровать данные по нескольким полям, необходимо воспользоваться оператором `AND`. Он используется для извлечения тех записей, которые удовлетворяют **всем** указанным условиям.

Результатом запроса:

```
SELECT trackname, artist, streams, release_date
FROM Songs
WHERE streams > 50000 AND release_date >= '2000-01-01';
```

будет:

```
+----------------------+------------+---------+--------------+
| trackname            | artist     | streams | release_date |
+----------------------+------------+---------+--------------+
| My Lover             | The Sounds | 99488   | 2009-05-31   |
| Spent the Day in Bed | Morrissey  | 174994  | 2017-09-19   |
+----------------------+------------+---------+--------------+
```

Здесь извлекаются данные о тех песнях что были прослушаны `streams` больше `50000` раз и дата выхода больше или равна `2000-01-01`. После оператора `WHERE` содержатся два условия, оператор `AND` используется для их объединения. Оператор `AND` говорит что должны быть возвращены только те записи, которые соответствуют двум условиям.

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Количество условий оператора WHERE может быть больше двух, в таком случае каждое из них должно отделяться отдельным оператором AND.
</p>
</div>
</kbd>

# Оператор OR

Действия оператора `OR` противоположны оператору `AND`, вместо того чтобы извлекать данные соответствующие нескольким условиям, оператор `OR` позволяет выводить результат если **хотя бы одно** из условий будет выполнено.

Результатом запроса:

```
SELECT trackname, artist
FROM Songs
WHERE artist = 'Heart' OR artist = 'Kate Bush';
```

будет:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy On You         | Heart     |
| Running up That Hill | Kate Bush |
+----------------------+-----------+
```

В этом запросе извлекаются данные о песнях исполнителями которых являются `Heart` и `Kate Bush`

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
В большинстве СУБД при использовании оператора OR второе условие не рассматривается, если выполняется первое. 
</p>
</div>
</kbd>

# Порядок обработки операторов

После оператора `WHERE` может содержаться любое количество логических операторов `AND` или `OR`. Однако стоит учитывать что оператор `AND` обрабатывается первым при комбинировании операторов `AND` и `OR`.

Результатом запроса:

```
SELECT trackname, artist, streams
FROM Songs
WHERE artist = 'The Sounds' OR artist = 'Kate Bush' AND streams > 50000;
```

будет:

```
+----------------------+------------+---------+
| trackname            | artist     | streams |
+----------------------+------------+---------+
| My Lover             | The Sounds | 99488   |
| Running up That Hill | Kate Bush  | 121495  |
| Thrill               | The Sounds | 49345   |
+----------------------+------------+---------+
```

Судя по результирующей таблице, записи были отфильтрованны не так как следует по условию. Так количество прослушиваний в результирующей таблице не превышает `50000`.

Чтобы составить корректный запрос, учитывающий все условия необходимо воспользоваться скобками и точно сгруппировать необходимые условия. В нашем случае в скобки нужно заключить часть условия с оператором `OR`, чтобы она имела больший приоритет и выполнялась первой.

Результатом запроса:

```
SELECT trackname, artist, streams
FROM Songs
WHERE (artist = 'The Sounds' OR artist = 'Kate Bush') AND streams > 50000;
```

будет:

```
+----------------------+------------+---------+
| trackname            | artist     | streams |
+----------------------+------------+---------+
| My Lover             | The Sounds | 99488   |
| Running up That Hill | Kate Bush  | 121495  |
+----------------------+------------+---------+
```

Теперь при извлечении **сначала** проверяется поле `artist` на предмет наличия `The Sounds` или `Kate Bush` а затем выполняется проверка на то больше ли `50000` поле `streams`.

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
При использовании логических операторов AND и OR рекомендуется всегда ставить скобки, чтобы точно сгруппировать условия. Не стоит полагаться на порядок обработки по умолчанию, даже если он подразумевает необходимый результат.
</p>
</div>
</kbd>

# Оператор IN

Оператор `IN` позволяет определить, совпадает ли значение в поле с одним из перечисленных.

Результатом запроса:

```
SELECT trackname, artist
FROM Songs
WHERE artist IN ('Heart', 'Kate Bush', 'Morrissey');
```

будет:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

Данный запрос извлекает данные о тех песнях, исполнителями которых являются `Heart`, `Kate Bush` и `Morrissey`. Оператор `IN` похож на оператор `OR`, приведенный ниже запрос с использованием `OR` равносилен использованию `IN`:

```
SELECT trackname, artist
FROM Songs
WHERE artist = 'Heart' OR artist = 'Kate Bush' OR artist = 'Morrissey';
```

Но оператор `IN` имеет некоторое преимущество переде оператором `OR`. При работе с большим количеством значений синтаксис оператора `IN` гораздо понятнее. Также при использовании оператора `IN` совместно с операторами `AND` и `OR` намного легче управлять порядком их обработки.

# Оператор NOT

Оператор `NOT` служит только одной цели - отрицать условия следующие за ним. С помощью данного оператора мы можем извлечь данные о тех песнях, исполнителями которых **не является** группа `The Sounds`.

Результатом запроса:

```
SELECT trackname, artist
FROM Songs
WHERE NOT artist = 'The Sounds';
```

будет:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

В данном случае можно и обойтись без оператора `NOT` составив запрос воспользовавшись лишь оператором сравнения `!=`.

Результатом запроса:

```
SELECT trackname, artist
FROM Songs
WHERE artist != 'The Sounds';
```

будет:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

Но в более сложных условиях можно воспользоваться оператором `NOT` в связке с оператором `IN`, что окажется предпочтительнее оператора `!=`.

Результатом запроса:

```
SELECT trackname, artist
FROM Songs
WHERE NOT artist IN ('Heart', 'Kate Bush', 'Morrissey');
```

будет:

```
+-----------+------------+
| trackname | artist     |
+-----------+------------+
| My Lover  | The Sounds |
| Thrill    | The Sounds |
+-----------+------------+
```

В этом запросе извлекаются данные о тех песнях, авторами которых **не являются** `Heart`, `Kate Bush`, `Morrissey`. Аналогичный запрос с использованием `!=` выглядел бы следующим образом:

```
SELECT trackname, artist
FROM Songs
WHERE artist != 'Heart' AND artist != 'Kate Bush' AND artist != 'Morrissey';
```

# Оператор NOT IN

Связка операторов `NOT`, `IN` довольно полезна но недостаточно наглядна. На практике для определения несоответствий списку значений требуется более очевидный оператор `NOT IN`, выполняющий ровно то же что и связка операторов `NOT` и `IN`.

Результатом запроса:

```
SELECT trackname, artist
FROM Songs
WHERE artist NOT IN ('Heart', 'Kate Bush', 'Morrissey');
```

будет:

```
+-----------+------------+
| trackname | artist     |
+-----------+------------+
| My Lover  | The Sounds |
| Thrill    | The Sounds |
+-----------+------------+
```

#### Примечание 1.

Логические операторы `AND`, `OR`, `NOT`, `IN` и `NOT IN` имеют разный приоритет обработки. В таблице ниже они представлены в **порядке уменьшения их приоритета**:

|    Оператор    |
|----------------|
| `IN`, `NOT IN` |
|     `NOT`      |
|     `AND`      |
|     `OR`       |

**Если условие содержит несколько логических операторов с одинаковым приоритетом, они выполняются слева направо.**

#### Примечание 2.

Оператор `NOT` отрицает только те условия, перед которыми он указан:

Результатом запроса:

```
SELECT id, artist
FROM Songs
WHERE NOT id = 1 OR id = 2;
```

будет:

```
+----+------------+
| id | artist     |
+----+------------+
| 2  | The Sounds |
| 3  | Kate Bush  |
| 4  | The Sounds |
| 5  | Morrissey  |
+----+------------+
```

В запросе указано два условия, но оператор `NOT` отрицает только первое из них. Для того чтобы он отрицал все условия, необходимо объединить их с помощью круглых скобок:

```
SELECT id, artist
FROM Songs
WHERE NOT (id = 1 OR id = 2);
```

и таким образом результатом будет:

```
+----+------------+
| id | artist     |
+----+------------+
| 3  | Kate Bush  |
| 4  | The Sounds |
| 5  | Morrissey  |
+----+------------+
```


# 3.6 Фильтрация данных. Часть 3

# Метасимволы и оператор LIKE

# Метасимвол %

# Метасимвол _

# Оператор LIKE BINARY

# 3.7 Создание вычисляемых полей

# Вычисляемые поля

# Объединение значений полей 

# Функция CONCAT_WS()

# Выполнение математических вычислений

