# 3.7 Создание вычисляемых полей

Используемая база данных:

```
+----+-------+----------------------+------------+-------+----------+
| id | place | trackname            | artist     | price | quantity |
+----+-------+----------------------+------------+-------+----------+
| 1  | 4     | Crazy On You         | Heart      | 2.00  | 31454    |
| 2  | 3     | My Lover             | The Sounds | 3.00  | 4558     |
| 3  | 2     | Running up That Hill | Kate Bush  | 1.00  | 15874    |
| 4  | 5     | Thrill               | The Sounds | 5.00  | 548      |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 5.00  | 564797   |
+----+-------+----------------------+------------+-------+----------+
```

# Вычисляемые поля

Данные, хранимые в таблицах базы данных, что бывают представлены не в том виде, в котором необходимы. 
Например, в таблице хранящей персональные данные людей, имя и фамилия человека могут находиться в разных полях, но может потребоваться указать их в одном поле. Другим примером может являться таблица, хранящая в себе детали интернет заказа. В одном поле таблицы может находиться количество приобретенного товара, в другом - цена за еденицу товара. Во время работы с такой таблицей, может понадобится общая стоимость - цена товара, умноженная на количество.

В каждом из примеров стоит задача получения информации, которая не хранится в базе данных в явном виде, однако может быть получена путем различных манипуляций. Для решения подобной задачи используются **вычисляемые поля** - поля, значения которых не хранятся в базе данных а вычисляются автоматически на основе данных из других полей таблицы. Вычисляемые поля используются для извлечения информации с дополнительными преобразованиями, подсчетами или форматированием.

**Вычисляемые поля определяются с использованием выражений, которые могут включать математические операции и вызовы различных функций**.

**Функция** - программная единица, предназначенная для выполнения различных операций с данными. Например, функция может переводить символы строки из нижнего в верхний регистр или возводить число в определенную степень. Каждая функция обладает **уникальным именем** и **набором аргументов**. Аргументы функции представляют собой данные, с которыми работает функция. Например аргументами функции, возводящей число в определенную степень, является само число и показатель степени.

Для вызова функции сначала указываем ее **имя**  а затем в скобках через запятую указываем **аргументы**. Например, вызов функции `POW()` для возведения числа `5` во `2` степень выглядит следующим образом:

```
POW(5, 2)
```

# Объединение значений полей 

Простым примером вычисляемого поля, является поле, которое содержит объединени значений из нескольких полей таблицы. Например, структура используемой таблицы `Songs` такова, что название песни и ее исполнитель, указываются в разных полях, однако можно определить вычисляемое поле, в котором сразу будут указаны и название и исполнитель.

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Операцию объединения или склеивания нескольких строк называют конкатенацией. Например, конкатенацией строк bee и geek станет строка beegeek.
</p>
</div>
</kbd>

В SQL для объединения нескольких значений используется функция `CONCAT()`. Она принимает переменное количество аргументов, выполняет их конкатенацию и возвращает полученный результат. Результатом функции `CONCAT()` всегда является **строка**, но аргументы функции могут принадлежать любым типам, поскольку функция неявно преобразует все аргументы в строки перед объединением.

Воспользуемся функцией `CONCAT()` и напишем запрос, который извлекает названия песен и их исполнителей, причем указывает эти данные в **одном поле**.

Результатом запроса:

```
SELECT CONCAT(artist, ' - ', trackname)
FROM Songs;
```

будет:

```
+----------------------------------+
| CONCAT(artist, ' - ', trackname) |
+----------------------------------+
| Heart - Crazy On You             |
| The Sounds - My Lover            |
| Kate Bush - Running up That Hill |
| The Sounds - Thrill              |
| Morrissey - Spent the Day in Bed |
+----------------------------------+
```

В данном примере функция `CONCAT()` выполняет объединение следующих значений: исполнителя песни, строки-разделителя (`-`) и названия песни. **Итогом является поле содержащее в себе три значения**.

Имя вычисляемого поля в результирующей таблице совпадает с выражением, которое это поле определяет. Чтобы вычисляемое поле получило более информативное название, ему **нужно дать псевдоним**.

Результатом запроса:

```
SELECT CONCAT(artist, ' - ', trackname) AS song
FROM Songs;
```

будет:

```
+----------------------------------+
| song                             |
+----------------------------------+
| Heart - Crazy On You             |
| The Sounds - My Lover            |
| Kate Bush - Running up That Hill |
| The Sounds - Thrill              |
| Morrissey - Spent the Day in Bed |
+----------------------------------+
```

Именовать вычисляемые поля необходимо не только для удобочитаемости, но и для возможности удобно обращаться к ним **в рамках запроса**, например, во время сортировки записей.

Результатом запроса:

```
​SELECT CONCAT(artist, ' - ', trackname) as song
FROM Songs
ORDER BY song DESC;
```

будет:

```
+----------------------------------+
| song                             |
+----------------------------------+
| The Sounds - Thrill              |
| The Sounds - My Lover            |
| Morrissey - Spent the Day in Bed |
| Kate Bush - Running up That Hill |
| Heart - Crazy On You             |
+----------------------------------+
```

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Ограничения на количество вычисляемых полей нет, их может быть как одно так и десять.
</p>
</div>
</kbd>

# Функция CONCAT_WS()

Для конкатенации значений в SQL существует дополнительная функция - `CONCAT_WS()`. В отличие от функции `CONCAT()` оно не только объединяет значения, но и добавляет разделитель между ними. **Разделитель указывается в качестве первого аргумента, объединяемые значения - в качестве всех остальных**. 

Результатом запроса:

```
SELECT CONCAT_WS(', ', id, artist, trackname) AS song
FROM Songs;
```

будет:

```
+------------------------------------+
| song                               |
+------------------------------------+
| 1, Heart, Crazy On You             |
| 2, The Sounds, My Lover            |
| 3, Kate Bush, Running up That Hill |
| 4, The Sounds, Thrill              |
| 5, Morrissey, Spent the Day in Bed |
+------------------------------------+
```

Здесь функция `CONCAT_WS()` объединяет значения полей `id`, `artist` и `trackname`, а в качестве разделителя используют строку `, `(запятая и пробел).

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
Функция CONCAT_WS(), как и функция CONCAT(), умеет работать с аргументами любых типов, поскольку перед объединением неявно преобразует все аргументы в строки.
</p>
</div>
</kbd>

# Выполнение математических вычислений

С помощью вычисляемых полей, можно решать задачи, требующие выполнения математических операций над извлекаемыми данными.

Структура таблицы `Songs` такова, что в ней для каждой песни указана цена и количество проданных копий. Общей суммы, которую принесли продажи каждой песни в таблице нет, однако она может быть получена путем умножения цены на количество проданных копий. В качестве примера составим запрос который выполняет данную операцию:

Результатом запроса:

```
SELECT artist, trackname,
       price * quantity AS revenue
FROM Songs;
```

будет:

```
+------------+----------------------+------------+
| artist     | trackname            | revenue    |
+------------+----------------------+------------+
| Heart      | Crazy On You         | 62908.00   |
| The Sounds | My Lover             | 13674.00   |
| Kate Bush  | Running up That Hill | 15874.00   |
| The Sounds | Thrill               | 2740.00    |
| Morrissey  | Spent the Day in Bed | 2823985.00 |
+------------+----------------------+------------+
```

Запрос выше вычисляет суммарную прибыль умножая значения пол] `price` на значения поля `quantity` и указывает полученный результат в поле `revenue` 

<kbd>
<div style="display:flex; align-items:center;">
<img src= "../bee.png" alt="пчелыч"  alt="пчелыч" style="width:50px; height:50px; margin-right:20px;">
<p>
В SQL поддерживаются основные математические операторы: + (сложение), - (вычитание), / (деление), * (умножение). Для управления порядком обработки операторв можно использовать круглые скобки.
</p>
</div>
</kbd>

#### Примечание 1.

Если хотя бы один из операндов в математическом выражении равен `NULL`, результатом всего выражения также будет значение `NULL`. 

Результатом приведенного запроса:

```
SELECT 1 + NULL,
       1 - NULL,
       1 * NULL,
       1 / NULL,
       (1 + NULL) / 2;
```

будет:

```
+----------+----------+----------+----------+----------------+
| 1 + NULL | 1 - NULL | 1 * NULL | 1 / NULL | (1 + NULL) / 2 |
+----------+----------+----------+----------+----------------+
| NULL     | NULL     | NULL     | NULL     | NULL           |
+----------+----------+----------+----------+----------------+
```

#### Примечание 2.

В `MySQL` результатом деления на `0` будет `NULL`. 

Результатом запроса:

```
SELECT 1 / 0;
```

будет:

```
+-------+
| 1 / 0 |
+-------+
| NULL  |
+-------+
```

При необходимости данное поведение может быть изменено в настройках СУБД, так, чтобы деление на ноль приводило к ошибке.

Однако в Postgres данная логика предусмотрена заранее и результатом деления на `0` будет ошибка.

Результатом запроса:

```
SELECT 1 / 0;
```

будет:

```
psql:commands.sql:1: ERROR:  division by zero
```

#### Примечание 3.

Псевдонимы вычисляемых полей, как и псевдонимы обычных полей, не могут быть использованы в блоке оператора `WHERE` для фильтрации записей.

Результатом запроса:

```
SELECT artist, trackname,
       price * quantity AS revenue
FROM Songs
WHERE revenue > 20000;
```

будет ошибка:

```
ERROR 1054: Unknown column 'revenue' in 'where clause'
```

При необходимости выполнения фильтрации вычисляемого поля, выражение определяющие это поле придется **продублировать**.

Результатом запроса:

```
SELECT artist, trackname,
       price * quantity AS revenue
FROM Songs
WHERE price * quantity > 20000;
```

будет:

```
+-----------+----------------------+------------+
| artist    | trackname            | revenue    |
+-----------+----------------------+------------+
| Heart     | Crazy On You         | 62908.00   |
| Morrissey | Spent the Day in Bed | 2823985.00 |
+-----------+----------------------+------------+
```

#### Примечание 4.

**Если хотя бы один из аргументов**, **переданных в функцию** `CONCAT()`, равняется `NULL`, функция вернет значение `NULL`.

Результатом запроса:

```
SELECT CONCAT('one', NULL, 3) AS result;
```

будет:

```
+--------+
| result |
+--------+
| NULL   |
+--------+
```

#### Примечание 5.

Если одно из объединяемых значений, переданных в функцию `CONCAT_WS()`, равняется `NULL`, при объединении оно будет проигнорированно.

Результатом запроса:

```
SELECT CONCAT_WS('-', 1, NULL, 3) AS result;
```

будет:

```
+--------+
| result |
+--------+
| 1-3    |
+--------+
```

Если же значение `NULL` примет разделитель, функция `CONCAT_WS()` вернет значение `NULL`.

Результатом запроса:

```
SELECT CONCAT_WS(NULL, 1, 2, 3) AS result;
```

будет:

```
+--------+
| result |
+--------+
| NULL   |
+--------+
```

#### Примечание 6.

Так как функции принимают значения и возвращают их, возвращаемое значение одной функции **может быть передано в качестве аргумента другой функции**.

Результатом запроса:

```
SELECT CONCAT('numbers: ', CONCAT_WS(', ', 1, 2, 3)) AS result;
```

будет:

```
+------------------+
| result           |
+------------------+
| numbers: 1, 2, 3 |
+------------------+
```

В данном примере cначала выполняется вложенная функция `CONCAT_WS()` и возвращает строку `1, 2, 3`. Затем полученная строка передается в функцию `CONCAT()` в качестве второго аргумента.

---